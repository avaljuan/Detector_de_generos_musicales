---
title: "J"
output: html_document
date: "2025-12-25"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
# Cargar paquetes

pacman::p_load(
  tuneR, seewave, dplyr, tidyverse, tidyr, here, readr, stringr,
  reticulate
)

base_dir <- "todas_musica"

generos <- list.dirs(base_dir, recursive = FALSE, full.names = FALSE)
generos <- unique(tolower(generos))
generos
```
```{r}
Sys.setenv(
  RETICULATE_PYTHON = file.path(reticulate::miniconda_path(), "envs", "env_audio", "python.exe")
)

reticulate::use_condaenv("env_audio", required = TRUE)

librosa <- reticulate::import("librosa")
np <- reticulate::import("numpy")
```

```{r}
calcular_ritmo_rap_reggae <- function(ruta_archivo, sr_obj = 48000, dur = 90) {

  audio_data <- librosa$load(
    ruta_archivo,
    sr = as.integer(sr_obj),
    mono = TRUE,
    offset = 0.0,
    duration = dur
  )
  y <- audio_data[[1]]
  sr <- audio_data[[2]]

  y <- y - mean(y)
  dur_real <- as.numeric(length(y) / sr)

  oenv <- librosa$onset$onset_strength(y = y, sr = sr)

  tempo_estimado <- librosa$beat$tempo(onset_envelope = oenv, sr = sr)
  bpm <- as.numeric(tempo_estimado)

  if (!is.na(bpm)) {
    if (bpm > 160) bpm <- bpm / 2
    if (bpm < 65)  bpm <- bpm * 2
  }

  tempo_log <- ifelse(is.na(bpm) | bpm <= 0, NA_real_, log2(bpm))
  fuerza_pulso <- as.numeric(mean(oenv))

  # (1) onset_rate
  onset_frames <- librosa$onset$onset_detect(onset_envelope = oenv, sr = sr, units = "frames")
  onset_rate <- as.numeric(length(onset_frames) / max(dur_real, 1e-6))

  # (2) high_onset_mean (hi-hats)
  mel_high <- librosa$feature$melspectrogram(
    y = y, sr = sr,
    fmin = 2000,
    fmax = min(8000, sr/2)
  )
  oenv_high <- librosa$onset$onset_strength(S = mel_high, sr = sr)
  high_onset_mean <- as.numeric(mean(oenv_high))

  # (3) offbeat_ratio
  bt <- librosa$beat$beat_track(onset_envelope = oenv, sr = sr, units = "frames")
  beat_frames <- bt[[2]]

  offbeat_ratio <- NA_real_
  if (length(beat_frames) >= 3) {
    beat_vals <- oenv[beat_frames + 1]
    mids <- floor((beat_frames[-1] + beat_frames[-length(beat_frames)]) / 2)
    mids <- mids[mids >= 0 & mids < length(oenv)]
    off_vals <- oenv[mids + 1]
    offbeat_ratio <- as.numeric(mean(off_vals) / max(mean(beat_vals), 1e-9))
  }

  c(
    Tempo_bpm = round(bpm, 2),
    TempoLog = round(tempo_log, 4),
    Fuerza_Pulso = round(fuerza_pulso, 4),
    onset_rate = round(onset_rate, 4),
    high_onset_mean = round(high_onset_mean, 4),
    offbeat_ratio = round(offbeat_ratio, 4)
  )
}
```


```{r}
## Declaramos funciones

importar_audio_normalizado <- function(path) {
  # 1. Cargar
  w <- tuneR::readWave(path)
  
  # 2. Convertir a Mono
  w <- tuneR::mono(w, which = "both")
  
  # 3. Recortar (30 a 120 segundos)
  w <- tuneR::extractWave(w, from = 0, to = 90, xunit = "time")
  
  # 4. Extraer vector para procesar
  x  <- w@left
  fs <- w@samp.rate
  
  # 5. Quitar DC (centrar la onda en 0)
  x <- x - mean(x)
  
  # 8. Construir objeto Wave para uso interno en R
  # Usamos bit = 32 y pcm = FALSE para que R entienda los decimales
  w <- tuneR::Wave(
    left = x, 
    samp.rate = fs, 
    bit = 32, 
    pcm = FALSE
  )
  
  # 7. Normalización a [-1, 1]
  w <- normalize(w)
  
  return(w)
}
```



```{r}
#ZCR

zcr_stats <- function(w, ms = 20, ovlp = 50){
  x  <- w@left
  fs <- w@samp.rate
  
  
  wl <- as.integer((ms/1000) * fs)
  Z <- seewave::zcr(x, f = fs, wl = wl, ovlp = ovlp, plot = FALSE)
  zvals <- Z[, "zcr"]
  
  slope <- coef(lm(zvals ~ seq_along(zvals)))[2]
  
  return(c(mean(zvals), sd(zvals)))
}
```


```{r}
#BER
# Conversión Hz -> Bark
hz2bark <- function(f) {
  13 * atan(0.00076 * f) + 3.5 * atan((f / 7500)^2)
}
metrica_BER <- function(signal, fs, wl = 1024, ovlp = 75) {
  
  spec <- spectro(
    signal,
    f = fs,
    wl = wl,
    ovlp = ovlp,
    plot = FALSE,
    norm = FALSE,
    dB = NULL
  )
  
  power_spec <- spec$amp^2
  
  # Frecuencias reales (Hz)
  freqs <- seq(0, fs/2, length.out = nrow(power_spec))
  bark_freq <- hz2bark(freqs)
  
  bark_ranges <- list(
    subbass  = c(1, 3),
    bass     = c(4, 6),
    low_mid  = c(7, 10),
    mid      = c(11, 14),
    high_mid = c(15, 18),
    treble   = c(19, 24)
  )
  
  total_energy <- sum(power_spec)
  
  BER <- numeric(length(bark_ranges))
  names(BER) <- names(bark_ranges)
  
  for (i in seq_along(bark_ranges)) {
    idx <- which(
      bark_freq >= bark_ranges[[i]][1] &
        bark_freq <= bark_ranges[[i]][2]
    )
    
    if (length(idx) > 0) {
      BER[i] <- sum(power_spec[idx, ]) / total_energy
    }
  }
  
  return(BER)
}
```





```{r}
# Espectrales
# Espectrales + BER
extraer_espectrales <- function(audio){
  fs <- audio@samp.rate
  spec <- meanspec(audio, f=fs, wl=1024, ovlp=50, plot=FALSE)

  props <- specprop(spec, f = spec[2,1], plot = FALSE)

  cent  <- props$mean
  bw    <- props$sd

  freq <- spec[,1] # kHz
  amp  <- spec[,2]

  # normaliza amplitud a densidad energética
  Pv <- amp^2 / sum(amp^2)

  cumP     <- cumsum(Pv)
  idx      <- which(cumP >= 0.85 )[1]
  rolloff_85 <- freq[idx]

  # BER por bandas Bark
  x <- audio@left
  ber <- metrica_BER(x, fs)

  return(
    c(
      cent*1000,
      bw*1000,
      rolloff_85*1000,
      ber
    )
  )
}


```


```{r}
# MFCC: 13 mean + 13 sd (tuneR::melfcc)
extraer_mfcc_stats <- function(audio, FS_OBJETIVO = 48000) {

  if (audio@samp.rate > FS_OBJETIVO) {
    audio <- downsample(audio, FS_OBJETIVO)
  }
  fs <- audio@samp.rate

  mf <- tuneR::melfcc(audio,
                      sr = fs,
                      numcep = 13,
                      wintime = 0.025,
                      hoptime = 0.010)

  mf_means <- colMeans(mf, na.rm = TRUE)
  mf_sds   <- apply(mf, 2, sd, na.rm = TRUE)

  c(mf_means, mf_sds)
}



```


```{r}
for (g in generos) {

  carpeta <- file.path(base_dir, g)
  names_files <- list.files(path = carpeta, pattern = "\\.wav$", ignore.case = TRUE)
  paths <- file.path(carpeta, names_files)
  n <- length(paths)

  song_names <- names_files

  AVG_Energy <- numeric(n)
  SD_Energy  <- numeric(n)
  ZCR_mean   <- numeric(n)
  ZCR_sd     <- numeric(n)
  Centroid   <- numeric(n)
  BW         <- numeric(n)
  RollOff    <- numeric(n)

  BER_subbass  <- numeric(n)
  BER_bass     <- numeric(n)
  BER_low_mid  <- numeric(n)
  BER_mid      <- numeric(n)
  BER_high_mid <- numeric(n)
  BER_treble   <- numeric(n)

  # ritmo + NUEVAS 3
  Tempo_bpm <- rep(NA_real_, n)
  TempoLog  <- rep(NA_real_, n)
  Fuerza_Pulso <- rep(NA_real_, n)
  onset_rate <- rep(NA_real_, n)
  high_onset_mean <- rep(NA_real_, n)
  offbeat_ratio <- rep(NA_real_, n)

  mfcc_mat <- matrix(NA_real_, nrow = n, ncol = 26)

  for (i in seq_along(paths)) {

    # R: cargar y sacar features acústicas
    w <- importar_audio_normalizado(paths[i])
    sound <- w@left

    acv <- acf(sound, plot = FALSE, type = "covariance", lag.max = 0)
    AVG_Energy[i] <- as.numeric(acv$acf[1])
    SD_Energy[i]  <- sd(sound^2)

    aux_zcr <- zcr_stats(w, ms = 20, ovlp = 50)
    ZCR_mean[i] <- aux_zcr[1]
    ZCR_sd[i]   <- aux_zcr[2]

    aux_es <- extraer_espectrales(w)
    Centroid[i] <- aux_es[1]
    BW[i]       <- aux_es[2]
    RollOff[i]  <- aux_es[3]

    ber_vals <- aux_es[4:9]
    BER_subbass[i]  <- ber_vals[1]
    BER_bass[i]     <- ber_vals[2]
    BER_low_mid[i]  <- ber_vals[3]
    BER_mid[i]      <- ber_vals[4]
    BER_high_mid[i] <- ber_vals[5]
    BER_treble[i]   <- ber_vals[6]

    mfcc_mat[i, ] <- extraer_mfcc_stats(w, FS_OBJETIVO = 48000)

    # Python/Librosa: ritmo + 3 features Rap/Reggae
    aux_r <- calcular_ritmo_rap_reggae(paths[i], sr_obj = 48000, dur = 90)
    Tempo_bpm[i] <- aux_r["Tempo_bpm"]
    TempoLog[i]  <- aux_r["TempoLog"]
    Fuerza_Pulso[i] <- aux_r["Fuerza_Pulso"]
    onset_rate[i] <- aux_r["onset_rate"]
    high_onset_mean[i] <- aux_r["high_onset_mean"]
    offbeat_ratio[i] <- aux_r["offbeat_ratio"]

    cat("Procesado:", g, i, "/", n, "-", names_files[i], "\n")

    rm(w, sound, acv, aux_zcr, aux_es, aux_r, ber_vals)
    if (i %% 3 == 0) gc()
  }

  features_gen <- data.frame(
    Song_Name = song_names,
    AVG_Energy = AVG_Energy,
    SD_Energy  = SD_Energy,
    ZCR_mean = ZCR_mean,
    ZCR_sd   = ZCR_sd,
    Centroid = Centroid,
    BW       = BW,
    RollOff  = RollOff,
    BER_subbass  = BER_subbass,
    BER_bass     = BER_bass,
    BER_low_mid  = BER_low_mid,
    BER_mid      = BER_mid,
    BER_high_mid = BER_high_mid,
    BER_treble   = BER_treble,

    Tempo_bpm = Tempo_bpm,
    TempoLog  = TempoLog,
    Fuerza_Pulso = Fuerza_Pulso,

    onset_rate = onset_rate,
    high_onset_mean = high_onset_mean,
    offbeat_ratio = offbeat_ratio,

    Genero = str_to_title(g),
    stringsAsFactors = FALSE
  )

  colnames_mfcc <- c(paste0("MFCC_", 1:13, "_mean"), paste0("MFCC_", 1:13, "_sd"))
  df_mfcc <- as.data.frame(mfcc_mat)
  colnames(df_mfcc) <- colnames_mfcc

  features_gen <- cbind(features_gen, df_mfcc)

  out_name <- paste0("features_", g, ".csv")
  write_csv(features_gen, out_name)

  cat("✅ guardado", out_name, "\n\n")

  rm(features_gen, df_mfcc, mfcc_mat)
  gc()
}

```





